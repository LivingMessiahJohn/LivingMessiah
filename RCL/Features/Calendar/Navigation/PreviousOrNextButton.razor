@using System.Linq
@using RCL.Features.Calendar.Data

@* @inject ILogger<PreviousOrNextButton>? Logger *@
@* @inject IJSRuntime JS *@
@* @inject IToastService? Toast *@

@if (!IsEdge)
{
	<button type="button" class="btn btn-outline-primary btn-md @Direction.Margin" title=""
					@onclick="ButtonClick">
		<i class="@Direction.Icon"></i>
	</button>
}
else
{
	<button class="btn btn-light btn-md disabled">
		<span class="text-black-50"><i class="fas fa-ban"></i></span>
	</button>
}

@code {
	[Parameter, EditorRequired] public DateOnly CurrentDate { get; set; }
	[Parameter, EditorRequired] public Enums.Direction Direction { get; set; }
	[Parameter, EditorRequired] public EventCallback<DateOnly> OnDateSelected { get; set; }

	private bool IsEdge;

	private DateRange? DateRange;

	private static int YearMonthKey(DateOnly d) => d.Year * 100 + d.Month;
	int currentKey;
	int startKey;
	int endKey;

	protected override void OnParametersSet()
	{
		DateRange = new DateRange(new DateOnly(CurrentDate.Year, 1, 1), new DateOnly(CurrentDate.Year, 12, 31));

		IsEdge = false;

		// Compare only Year and Month, not the full DateOnly value.

		currentKey = YearMonthKey(CurrentDate);
		startKey = YearMonthKey(DateRange!.Start);
		endKey = YearMonthKey(DateRange!.End);


		if (Direction == Enums.Direction.Previous && currentKey <= startKey)
		{
			IsEdge = true;
		}
		else if (Direction == Enums.Direction.Next && currentKey >= endKey)
		{
			IsEdge = true;
		}
	}

	//private IJSObjectReference? jsModule;
	//private DotNetObjectReference<PreviousOrNextButton>? _dotNetRef;

	protected override async Task OnAfterRenderAsync(bool firstRender)
	{
		if (firstRender)
		{
			//try
			//{
			/*
				jsModule = await JS.InvokeAsync<IJSObjectReference>("import", "./Features/Calendar/PreviousOrNextButton.razor.js");
				_dotNetRef = DotNetObjectReference.Create(this);
				await jsModule.InvokeVoidAsync("addArrowKeyListener", _dotNetRef);
				*/
				//Logger!.LogInformation("{Method}, JSMethod: {JSMethod}", nameof(OnAfterRenderAsync), JsonKeyboard.Method);
			//}
			//catch (Exception ex)
			//{
				//Logger!.LogError(ex, "{Method}", nameof(OnAfterRenderAsync));
				//Toast!.ShowError("An invalid operation occurred, contact your administrator");
			//}
		}
	}

	private void ButtonClick()
	{
		ExecuteMove();
	}

	private void ExecuteMove()
	{
		if (DateRange is null) { return; }

		DateOnly adjustedDateOnly = Direction == Enums.Direction.Previous
			? CurrentDate.AddMonths(-1)
			: CurrentDate.AddMonths(+1);

		OnDateSelected.InvokeAsync(adjustedDateOnly);
	}

	/*
	THIS DOESN'T WORK WHY!!!
	private void ExecuteMoveViaKeyboard(Enums.Direction direction)
	{
		if (DateOnlyRange is null) { return; }

		DateOnly adjustedDateOnly = direction == Enums.Direction.Previous
			? CurrentDateOnly.AddMonths(-1)
			: CurrentDateOnly.AddMonths(+1);

		Toast!.ShowWarning($"IsEdge: {IsEdge}; dir: {direction.Name}; adjustedDate: {adjustedDateOnly.Year} {adjustedDateOnly.Month}");
		
		OnDateOnlySelected.InvokeAsync(adjustedDateOnly);
	}

	[JSInvokable]
	public void HandleArrowKey(string key)
	{
		if (key != Enums.Direction.Previous.KeyboardKey && key != Enums.Direction.Next.KeyboardKey) { return; }
		//if (!IsEdge) { return; }

		if (Direction == Enums.Direction.Previous && key == Enums.Direction.Previous.KeyboardKey)
		{
			ExecuteMoveViaKeyboard(Enums.Direction.Previous);
		}
		else if (Direction == Enums.Direction.Next && key == Enums.Direction.Next.KeyboardKey)
		{
			ExecuteMoveViaKeyboard(Enums.Direction.Next);
		}
	}
	
	public async ValueTask DisposeAsync()
	{
		if (jsModule != null)
		{
			await jsModule.InvokeVoidAsync("removeArrowKeyListener");
			await jsModule.DisposeAsync();
		}
		_dotNetRef?.Dispose();
	}
	*/
}

