@using RCL.Features.Calendar.Data

@* @inject ILogger<PreviousOrNextButton>? Logger *@
@inject IJSRuntime JS
@* @inject IToastService? Toast *@
@inject RCL.Features.Calendar.Data.IService? Service


@if (!IsEdge)
{
	<button type="button" class="btn btn-outline-primary btn-md @Direction.Margin"
					title="Date: @CurrentDateOnly.Year @CurrentDateOnly.Month Range: @DateOnlyRange"
					@onclick="ButtonClick">
		<i class="@Direction.Icon"></i>
	</button>
}
else
{
	<button class="btn btn-light btn-md disabled">
		<span class="text-black-50"><i class="fas fa-ban"></i></span>
	</button>
}



@code {
	[Parameter, EditorRequired] public DateOnly CurrentDateOnly { get; set; }
	[Parameter, EditorRequired] public Enums.Direction Direction { get; set; }
	[Parameter, EditorRequired] public EventCallback<DateOnly> OnDateOnlySelected { get; set; }

	private bool IsEdge;

	private DateOnlyRange? DateOnlyRange;

	private static int YearMonthKey(DateOnly d) => d.Year * 100 + d.Month;
	int currentKey;
	int startKey;
	int endKey;

	protected override void OnParametersSet()
	{
		//Populate();
		DateOnlyRange = Service!.GetDateRange();

		IsEdge = false;
		if (DateOnlyRange is null) { return; }

		// Compare only Year and Month, not the full DateOnly value.

		currentKey = YearMonthKey(CurrentDateOnly);
		startKey = YearMonthKey(DateOnlyRange!.Start);
		endKey = YearMonthKey(DateOnlyRange!.End);

		if (Direction == Enums.Direction.Previous && currentKey <= startKey)
		{
			IsEdge = true;
		}
		else if (Direction == Enums.Direction.Next && currentKey >= endKey)
		{
			IsEdge = true;
		}
	}



	private IJSObjectReference? jsModule;
	private DotNetObjectReference<PreviousOrNextButton>? _dotNetRef;

	protected override async Task OnAfterRenderAsync(bool firstRender)
	{
		if (firstRender)
		{
			try
			{
				jsModule = await JS.InvokeAsync<IJSObjectReference>("import", "./Features/Calendar/PreviousOrNextButton.razor.js");
				_dotNetRef = DotNetObjectReference.Create(this);
				await jsModule.InvokeVoidAsync("addArrowKeyListener", _dotNetRef);
				//Logger!.LogInformation("{Method}, JSMethod: {JSMethod}", nameof(OnAfterRenderAsync), JsonKeyboard.Method);
			}
			catch (Exception ex)
			{
				//Logger!.LogError(ex, "{Method}", nameof(OnAfterRenderAsync));
				//Toast!.ShowError("An invalid operation occurred, contact your administrator");
			}
		}
	}

	private void ButtonClick()
	{
		ExecuteMove();
	}

	private void ExecuteMove()
	{
		if (DateOnlyRange is null) { return; }

		DateOnly adjustedDateOnly = Direction == Enums.Direction.Previous
			? CurrentDateOnly.AddMonths(-1)
			: CurrentDateOnly.AddMonths(+1);

		OnDateOnlySelected.InvokeAsync(adjustedDateOnly);
	}

	/*
	THIS DOESN'T WORK WHY!!!
	private void ExecuteMoveViaKeyboard(Enums.Direction direction)
	{
		if (DateOnlyRange is null) { return; }

		DateOnly adjustedDateOnly = direction == Enums.Direction.Previous
			? CurrentDateOnly.AddMonths(-1)
			: CurrentDateOnly.AddMonths(+1);

		Toast!.ShowWarning($"IsEdge: {IsEdge}; dir: {direction.Name}; adjustedDate: {adjustedDateOnly.Year} {adjustedDateOnly.Month}");
		
		OnDateOnlySelected.InvokeAsync(adjustedDateOnly);
	}

	[JSInvokable]
	public void HandleArrowKey(string key)
	{
		if (key != Enums.Direction.Previous.KeyboardKey && key != Enums.Direction.Next.KeyboardKey) { return; }
		//if (!IsEdge) { return; }

		if (Direction == Enums.Direction.Previous && key == Enums.Direction.Previous.KeyboardKey)
		{
			ExecuteMoveViaKeyboard(Enums.Direction.Previous);
		}
		else if (Direction == Enums.Direction.Next && key == Enums.Direction.Next.KeyboardKey)
		{
			ExecuteMoveViaKeyboard(Enums.Direction.Next);
		}
	}
	*/
	
	public async ValueTask DisposeAsync()
	{
		if (jsModule != null)
		{
			await jsModule.InvokeVoidAsync("removeArrowKeyListener");
			await jsModule.DisposeAsync();
		}
		_dotNetRef?.Dispose();
	}
}

